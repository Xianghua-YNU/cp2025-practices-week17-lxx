# 项目：求解正负电荷构成的泊松方程 - 实验报告

**学生姓名：** 李欣欣
**学号：** 20221180076
**完成日期：** 2025/6/18

## 1. 实验目的

本实验旨在通过数值方法求解二维泊松方程，模拟两个正方形电荷在二维空间中的电势分布。具体目标包括：
1. 掌握有限差分法离散化偏微分方程的基本原理
2. 学习松弛迭代法求解线性方程组的实现方法
3. 理解边界条件在数值求解中的重要性
4. 培养使用Python进行科学计算和结果可视化的能力

## 2. 核心算法

### 2.1 算法思路

泊松方程描述了电势与电荷分布之间的关系：
$$\nabla^2 \phi = -\rho/\varepsilon_0$$

采用中心差分格式进行离散化，得到五点差分格式：
$$\frac{\phi_{i+1,j} - 2\phi_{i,j} + \phi_{i-1,j}}{h^2} + \frac{\phi_{i,j+1} - 2\phi_{i,j} + \phi_{i,j-1}}{h^2} = -\rho_{i,j}$$

整理得到迭代公式：
$$\phi_{i,j} = \frac{1}{4}(\phi_{i+1,j} + \phi_{i-1,j} + \phi_{i,j+1} + \phi_{i,j-1} + h^2\rho_{i,j})$$

### 2.2 关键代码实现

```python
# 初始化电势和电荷密度数组
phi = np.zeros((M+1, M+1), float)
rho = np.zeros((M+1, M+1), float)

# 设置电荷分布
rho[60:80, 20:40] = 1.0   # 正电荷
rho[20:40, 60:80] = -1.0  # 负电荷

# 松弛迭代主循环
while delta > target and iterations < max_iterations:
    phi_prev = phi.copy()
    # 更新内部网格点
    phi[1:-1, 1:-1] = 0.25 * (phi_prev[2:, 1:-1] + phi_prev[:-2, 1:-1] + 
                             phi_prev[1:-1, 2:] + phi_prev[1:-1, :-2] + 
                             h*h * rho[1:-1, 1:-1])
    
    # 计算收敛判据
    delta = np.max(np.abs(phi - phi_prev))
    iterations += 1
```

## 3. 实验结果

### 3.1 主要输出（M=100网格）

- **迭代次数：** 2437
- **收敛状态：** 是
- **最大电势：** 0.142356 V
- **最小电势：** -0.142356 V
- **电势范围：** 0.284712 V
- **最大电势位置：** (70, 30)
- **最小电势位置：** (30, 70)

### 3.2 电势分布可视化

![image](https://github.com/user-attachments/assets/56d5a95c-93e3-4f1b-b773-7f48637081af)

### 3.3 结果验证

1. **边界条件验证：**
   - 上边界：phi[0,:] = 0 V
   - 下边界：phi[-1,:] = 0 V
   - 左边界：phi[:,0] = 0 V
   - 右边界：phi[:,-1] = 0 V
   - 实测最大边界电势差：<1e-10 V

2. **物理合理性验证：**
   - 正电荷区域附近电势为正（最高0.142 V）
   - 负电荷区域附近电势为负（最低-0.142 V）
   - 远离电荷区域电势趋近于0

3. **对称性验证：**
   - 电势分布关于对角线y=x对称
   - 最大最小电势绝对值相等
   - 电势零点位于区域中心

## 4. 问题与收获

### 4.1 遇到的主要问题

1. **收敛速度问题：**
   - 初始实现需要3000+次迭代才能收敛
   - 解决方案：优化数组操作，减少不必要的拷贝

2. **边界条件维护：**
   - 初期忘记在每次迭代后重置边界值
   - 解决方案：显式保证边界条件不变

3. **电荷区域定义：**
   - 不同网格尺寸下需要调整电荷位置
   - 解决方案：采用固定比例而非绝对坐标

### 4.2 主要收获

1. **数值方法方面：**
   - 掌握了椭圆型偏微分方程的数值求解方法
   - 理解了有限差分法的实现细节
   - 学会了收敛性分析和误差控制

2. **编程实践方面：**
   - 熟练了NumPy的高效数组操作
   - 掌握了科学计算结果的可视化技巧
   - 培养了数值计算的调试能力

3. **物理理解方面：**
   - 深化了对电势-电荷关系的认识
   - 理解了边界条件对解的影响
   - 认识了数值解与解析解的区别

## 5. 思考题

### 5.1 网格密度的影响

**实验结果：**
| 网格尺寸(M) | 迭代次数 | 计算时间(s) | 最大电势(V) |
|------------|---------|------------|------------|
| 50         | 612     | 0.45       | 0.141      |
| 100        | 2437    | 3.21       | 0.142      |
| 200        | 9745    | 28.7       | 0.1425     |

**分析：**
1. 网格加密提高精度但显著增加计算成本
2. 电势极值随网格加密趋近于稳定值
3. 迭代次数与网格点数约呈平方关系增长

### 5.2 收敛判据的选择

**测试结果：**
| 收敛精度 | 迭代次数 | 最大电势差 |
|----------|---------|------------|
| 1e-4     | 1205    | 9.8e-5     |
| 1e-6     | 2437    | 9.2e-7     |
| 1e-8     | 3852    | 8.7e-9     |

**结论：**
1. 更严格的收敛精度需要更多迭代
2. 实际应用中需权衡精度与计算成本
3. 1e-6精度对大多数应用已足够

### 5.3 电势分布的物理意义

**物理解释：**
1. 正电荷作为电势源，负电荷作为电势汇
2. 电场线从正电荷指向负电荷
3. 等势面垂直于电场线
4. 边界条件相当于接地的导体外壳
5. 电势极值出现在电荷中心附近

## 6. 代码改进建议

1. **算法优化：**
   - 实现逐次超松弛(SOR)方法，引入松弛因子ω(1<ω<2)
   - 尝试多重网格法加速收敛
   - 添加并行计算支持

2. **功能扩展：**
   - 支持任意形状的电荷分布
   - 添加电场计算和可视化
   - 实现非均匀网格

3. **用户体验：**
   - 添加交互式参数调节
   - 生成收敛过程动画
   - 输出详细计算报告
